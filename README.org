#+TITLE: BlockMaps.jl
#+AUTHOR: Stefanos Carlström
#+EMAIL: stefanos.carlstrom@gmail.com

[[https://travis-ci.org/jagot/BlockMaps.jl][https://travis-ci.org/jagot/BlockMaps.jl.svg?branch=master]]
[[https://coveralls.io/github/jagot/BlockMaps.jl?branch=master][https://coveralls.io/repos/jagot/BlockMaps.jl/badge.svg?branch=master&service=github]]
[[http://codecov.io/github/jagot/BlockMaps.jl?branch=master][http://codecov.io/github/jagot/BlockMaps.jl/coverage.svg?branch=master]]

#+PROPERTY: header-args:julia :session *julia-README*

A simple application of [[https://github.com/Jutho/LinearMaps.jl][LinearMaps.jl]] to block matrices, i.e. matrices
which are mostly sparse, but have non-zero blocks which are mostly
dense.

* Usage
  #+BEGIN_SRC julia :exports code
    using BlockMaps
  #+END_SRC

  #+RESULTS:
  : nothing
  
  #+BEGIN_SRC julia :exports none
    using PyPlot
    using Jagot.plotting
    plot_style("ggplot")
  #+END_SRC

  #+RESULTS:
  : nothing

  To construct the block matrix, simply create an empty =BlockMap= and
  assign dense blocks to the desired locations:
  #+BEGIN_SRC julia :exports both :results verbatim
    B = BlockMaps.BlockMap(Float64, 10, 10)
    a = Float64[-1 2; 2 1]
    b = Float64[-1 2 3; 2 1 -4]
    B[1,1] = a
    B[1,3] = a
    B[1,9] = a
    B[4,6] = b
    B[6,8] = b
    B[9,9] = a
    B
  #+END_SRC

  #+RESULTS:

  Hinton plot of the resultant matrix:
  #+BEGIN_SRC julia :exports results :results file
    figure("matrix")
    clf()
    hinton_plot_matrix(full(B))
    tight_layout()
    savefig("figures/matrix.svg")
    "figures/matrix.svg"
  #+END_SRC

  #+RESULTS:
  [[file:figures/matrix.svg]]


  If the matrix is specified to be symmetric/Hermitian, the block
  (complex conjugated) transposes will be handled automatically:
  #+BEGIN_SRC julia :exports both :results verbatim
    B = BlockMaps.BlockMap(Float64, 10, 10, issymmetric=true)
    a = Float64[-1 2; 2 1]
    b = Float64[-1 2 3; 2 1 -4]
    B[1,1] = a
    B[1,3] = a
    B[1,9] = a
    B[4,6] = b
    B[6,8] = b
    B[9,9] = a
    B
  #+END_SRC

  #+RESULTS:
  : BlockMaps.BlockMap{Float64}(10, 10, BlockMaps.Block{Float64}[2x2 Float64 block at (1,1), 2x2 Float64 block at (1,3), 2x2 Float64 block at (1,9), 2x3 Float64 block at (4,6), 2x3 Float64 block at (6,8), 2x2 Float64 block at (9,9)], true, true, false)

  #+BEGIN_SRC julia :exports results :results file
    figure("symmetric matrix")
    clf()
    hinton_plot_matrix(full(B))
    tight_layout()
    savefig("figures/symmetric-matrix.svg")
    "figures/symmetric-matrix.svg"
  #+END_SRC

  #+RESULTS:
  [[file:figures/symmetric-matrix.svg]]

* Known issues
  - The blocks are processed in the order they where assigned,
    possibly leading to suboptimal performance. Maybe a
    =sort!(A::BlockMap)= operation should be implemented.
  - Parallelization?
  - A “power user” mode should be implemented, allowing overlapping
    blocks, where the user is responsible for the overlapping regions
    being applied only once (or maybe the overlap can be cleared
    automatically by BlockMaps.jl?); this is useful in FEM
    applications, where the Laplace operator is almost block-diagonal,
    with one matrix element overlapping between subsequent blocks.
